; The number of arguments to proccess.
    count=1000000

; Put the start of arguments chunk into rax.
    sub rax, 1
    imul rax, count

; Fill `cubes` array.
    cubes=buffer
    zer rdi
@@: inc rdi
    mov rbx, rdi
    imul rbx, rdi; ^2
    imul rbx, rdi; ^3
    mov [cubes+rdi*8], rbx
    sub rbx, count
    cmp rbx, rax
    jl @b

; Store the highest index.
    mov rcx, rdi

; Prepare `results` array.
    results=buffer+5000*8
    zer r15
    zerLoop:
        mov byte [results+r15], 0
        inc r15
        cmp r15, count
        jna zerLoop

; Check every combination, x>=y>=z.
    mov r12, 1 ; x
    xLoop:
        mov r13, 1 ; y
        yLoop:
            mov r14, 1 ; z
            zLoop:
                mov r15, [cubes+r12*8]
                add r15, [cubes+r13*8]
                add r15, [cubes+r14*8]

                sub r15, rax
                cmp r15, 0
                jb @f
                cmp r15, count
                ja @f

                inc byte [results+r15]

            @@: inc r14
                cmp r14, r13
                jna zLoop
            inc r13
            cmp r13, r12
            jna yLoop
        inc r12
        cmp r12, rcx
        jna xLoop

; Push all results.
    zer r8
    pushLoop:
        movzx rbx, byte [results+r8]
        cmp rbx, 0
        je @f
        push rdx
        push rbx
        push rdi
        mov r9, rax
        add r9, r8
        push r9
    @@: inc r8
        cmp r8, count
        jb pushLoop
